--- a/src/Plugin/jsonapi/FieldEnhancer/UrlLinkEnhancer.php	2026-01-02 12:24:25
+++ b/src/Plugin/jsonapi/FieldEnhancer/UrlLinkEnhancer.php	2026-01-02 12:23:17
@@ -107,15 +107,17 @@
   protected function doUndoTransform($data, Context $context) {
     if (isset($data['uri'])) {
       try {
-        $url = Url::fromUri($data['uri'], ['language' => $this->languageManager->getCurrentLanguage(LanguageInterface::TYPE_CONTENT)]);
+        $urlObject = Url::fromUri($data['uri'], ['language' => $this->languageManager->getCurrentLanguage(LanguageInterface::TYPE_CONTENT)]);
 
         // Use absolute urls if configured.
         $configuration = $this->getConfiguration();
         if ($configuration['absolute_url']) {
-          $url->setAbsolute(TRUE);
+          $urlObject->setAbsolute(TRUE);
         }
 
-        $data['url'] = $url->toString();
+        $url = $urlObject->toString();
+        $url = $this->ensureTrailingSlashForNodeLinks($data['uri'], $url);
+        $data['url'] = $url;
       }
       catch (\Exception $e) {
         $this->logger->error('Failed to create a URL from uri @uri. Error: @error', [
@@ -129,6 +131,86 @@
   }
 
   /**
+   * Ensures node entity URLs have a trailing slash.
+   *
+   * VA.gov canonical URLs use trailing slashes. This method adds a trailing
+   * slash to URLs that originate from node entity references (entity:node/XXX),
+   * which represent Drupal page content.
+   *
+   * This is intentionally conservative - it only modifies URLs where we know
+   * with certainty that a trailing slash is appropriate (node pages), and
+   * leaves all other URL types unchanged.
+   *
+   * @param string $uri
+   *   The original URI (e.g., 'entity:node/123').
+   * @param string $url
+   *   The resolved URL string to potentially modify.
+   *
+   * @return string
+   *   The URL with a trailing slash added if it's a node entity link.
+   */
+  protected function ensureTrailingSlashForNodeLinks(string $uri, string $url): string {
+    // Only process node entity references.
+    if (!str_starts_with($uri, 'entity:node/')) {
+      return $url;
+    }
+
+    // Parse the URL so we can safely modify only the path component.
+    $parts = parse_url($url);
+    if ($parts === FALSE || !isset($parts['path'])) {
+      // If parsing fails or there is no path, leave the URL unchanged.
+      return $url;
+    }
+
+    // If the path already ends with a slash, do nothing.
+    if (str_ends_with($parts['path'], '/')) {
+      return $url;
+    }
+
+    // Add a trailing slash to the path only.
+    $parts['path'] = $parts['path'] . '/';
+
+    // Rebuild the URL from its components, preserving query and fragment.
+    $rebuilt = '';
+
+    if (isset($parts['scheme'])) {
+      $rebuilt .= $parts['scheme'] . '://';
+    }
+
+    if (isset($parts['user'])) {
+      $rebuilt .= $parts['user'];
+      if (isset($parts['pass'])) {
+        $rebuilt .= ':' . $parts['pass'];
+      }
+      $rebuilt .= '@';
+    }
+
+    if (isset($parts['host'])) {
+      $rebuilt .= $parts['host'];
+    }
+
+    if (isset($parts['port'])) {
+      $rebuilt .= ':' . $parts['port'];
+    }
+
+    if (isset($parts['path'])) {
+      $rebuilt .= $parts['path'];
+    }
+
+    if (isset($parts['query'])) {
+      $rebuilt .= '?' . $parts['query'];
+    }
+
+    if (isset($parts['fragment'])) {
+      $rebuilt .= '#' . $parts['fragment'];
+    }
+
+    // Fallback to the original URL if reconstruction somehow yields an
+    // empty string.
+    return $rebuilt !== '' ? $rebuilt : $url;
+  }
+
+  /**
    * {@inheritdoc}
    */
   protected function doTransform($value, Context $context) {
