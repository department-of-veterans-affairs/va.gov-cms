<?php

/**
 * @file
 * Install and update hooks for Va.gov Multilingual.
 */

use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;

/**
 * Implements hook_update_install().
 *
 * This is only here for demonstrating the POC.
 */
function va_gov_multilingual_install() {
  va_gov_multilingual_update_9001();
}

/**
 * Implements hook_update_N().
 */
function va_gov_multilingual_update_9001() {
  va_gov_multilingual_convert_short_text_field('node', 'field_clp_events_header');
}

/**
 * Utility function for in-place field conversion.
 *
 * This function converts existing `string` and `text` fields to their `_long`
 * equivalents.
 */
function va_gov_multilingual_convert_short_text_field($entity_type, $field_name) {
  $database = \Drupal::database();

  $data_temp = [];
  $config_temp = [
    '_entity_type' => $entity_type,
    '_field_name' => $field_name,
  ];
  // If we cannot find field storage config for this combination, exit.
  if (!$field_storage_config = FieldStorageConfig::loadByName($entity_type, $field_name)) {
    // message: "Cannot find $field_name on entity type $entity_type.".
    return;
  }
  // If this is not a `string` or `text` field type, exit.
  if (!in_array($field_storage_config->getType(), ['string', 'text'])) {
    // message: "Not modifying $field_name of type $field_type.".
    return;
  }
  $config_temp['_field_storage'] = $field_storage_config->toArray();
  // Grab the existing data and hold it for safe-keeping.
  $primary_table = "{$entity_type}__{$field_name}";
  if ($database->schema()->tableExists($primary_table)) {
    // The table data to restore after the update is completed.
    $data_temp['primary_data'] = $database->select($primary_table, 'n')
      ->fields('n')
      ->execute()
      ->fetchAll();
    // If we didn't get any content from this, something is wrong; bail.
    if (empty($data_temp['primary_data'])) {
      return;
    }
  }
  // Create table backups prior to dropping them.
  if ($database->schema()->tableExists("{$primary_table}_backup")) {
    $database->query("DROP TABLE {$primary_table}_backup");
  }
  $database->query("CREATE TABLE {$primary_table}_backup AS SELECT * FROM {$primary_table}");
  $revision_table = "{$entity_type}_revision__{$field_name}";
  if ($database->schema()->tableExists($revision_table)) {
    $data_temp['revision_data'] = $database->select($revision_table, 'n')
      ->fields('n')
      ->execute()
      ->fetchAll();
    // If we didn't get any content from this, something is wrong; bail.
    if (empty($data_temp['revision_data'])) {
      return;
    }
  }
  // Create table backups prior to dropping them.
  if ($database->schema()->tableExists("{$revision_table}_backup")) {
    $database->query("DROP TABLE {$revision_table}_backup");
  }
  $database->query("CREATE TABLE {$revision_table}_backup AS SELECT * FROM {$revision_table}");

  // Use existing field config for new fields.
  // This retrieves each instance of the field off its bundle.
  $config_temp['bundles'] = [];
  foreach ($field_storage_config->getBundles() as $bundle => $label) {
    $entity_display_repository = \Drupal::service('entity_display.repository');
    $field_config = FieldConfig::loadByName($entity_type, $bundle, $field_name);
    $config_temp['bundles'][$bundle]['field_config'] = $field_config->toArray();

    // Retrieve form display settings and save them for later.
    $entity_form_display_options = $entity_display_repository->getFormModeOptionsByBundle($entity_type, $bundle);
    foreach ($entity_form_display_options as $form_mode => $options) {
      $entity_form_display_config = \Drupal::service('entity_display.repository')
        ->getFormDisplay($entity_type, $bundle, $form_mode);
      // ['content'] grabs only settings for fields that are visible.
      $config_temp[$bundle]['entity_form_display_config'][$form_mode] = $entity_form_display_config->toArray()['content'];
    }
    // Retrieve view display settings and save them for later.
    $entity_view_display_options = $entity_display_repository->getViewModeOptionsByBundle($entity_type, $bundle);
    foreach ($entity_view_display_options as $view_mode => $options) {
      $entity_view_display_config = \Drupal::service('entity_display.repository')
        ->getViewDisplay($entity_type, $bundle, $view_mode);
      // ['content'] grabs only settings for fields that are visible.
      $config_temp[$bundle]['entity_view_display_config'][$view_mode] = $entity_view_display_config->toArray()['content'];
    }
  }
  // Keep a copy of the collected config for reference.
  $config_backup = $config_temp;
  // This will delete all data for field_storage and fields instances.
  $field_storage_config->delete();
  // Purge field data now to allow new field and field_storage with same name
  // to be created.
  field_purge_batch(100);
  // Change the field storage to the appropriate new type.
  $config_temp['_field_storage']['type'] = $config_backup['_field_storage']['type'] . '_long';
  // The _long field types do not have settings at the storage level.
  $config_temp['_field_storage']['settings'] = [];
  // Create new field storage.
  $new_field_storage = FieldStorageConfig::create($config_temp['_field_storage']);
  $new_field_storage->save();

  foreach ($config_temp['bundles'] as $bundle => $saved_config) {
    // Recreate each field instance on its bundle. There are no changes from the
    // previous configuration.
    $config_temp['bundles'][$bundle]['field_config']['type'] = $config_backup['_field_storage']['type'];
    $config_temp['bundles'][$bundle]['field_config']['settings'] = [];
    $new_field = FieldConfig::create($config_temp['bundles'][$bundle]['field_config']);
    $new_field->save();

    // We will now cycle through each form mode for this bundle and recreate its
    // settings, making the modification to add the counter field if needed.
    $entity_form_display_options = $entity_display_repository->getFormModeOptionsByBundle($entity_type, $bundle);
    foreach ($entity_form_display_options as $form_mode => $options) {
      $entity_form_display_config = \Drupal::service('entity_display.repository')
        ->getFormDisplay($entity_type, $bundle, $form_mode);
      // We get each active component from the form display config and re-save
      // it using the pre-field change settings.
      foreach ($entity_form_display_config->getComponents() as $name => $options) {
        $saved_form_display_config = $config_temp[$bundle]['entity_form_display_config'][$form_mode];
        if (isset($saved_form_display_config[$name])) {
          // Only modify the field widget we care about, and if it already has
          // a counter, leave it alone.
          if ($name === $field_name && ($saved_form_display_config[$field_name]['type'] !== $field_storage_config->getType() . '_textfield_with_counter')) {
            // This is what we're aiming to update.
            $saved_form_display_config[$field_name]['type'] = $config_backup['_field_storage']['type'] . '_textfield_with_counter';
            $saved_form_display_config[$field_name]['settings']['maxlength'] = $config_backup['_field_storage']['settings']['max_length'];
          }
          $entity_form_display_config->setComponent($name, $saved_form_display_config[$name]);

        }
      }
      $entity_form_display_config->save();
    }
    // Do the same for view displays. We are just replacing the old settings.
    $entity_view_display_options = $entity_display_repository->getViewModeOptionsByBundle($entity_type, $bundle);
    foreach ($entity_view_display_options as $view_mode => $options) {
      $entity_view_display_config = \Drupal::service('entity_display.repository')
        ->getViewDisplay($entity_type, $bundle, $view_mode);
      foreach ($entity_view_display_config->getComponents() as $name => $options) {
        $saved_view_display_config = $config_temp[$bundle]['entity_view_display_config'][$view_mode];
        if (isset($saved_view_display_config[$name])) {
          $entity_view_display_config->setComponent($name, $saved_view_display_config[$name]);

        }
      }
      $entity_view_display_config->save();
    }
  }
  // Reinstert the data.
  if (!is_null($data_temp['primary_data'])) {
    foreach ($data_temp['primary_data'] as $row) {
      $database->insert($primary_table)
        ->fields((array) $row)
        ->execute();
    }
  }
  if (!is_null($data_temp['revision_data'])) {
    foreach ($data_temp['revision_data'] as $row) {
      $database->insert($revision_table)
        ->fields((array) $row)
        ->execute();
    }
  }
}
